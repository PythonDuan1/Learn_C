#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>
#include<string.h>

//指针
// 
//指针就是地址，口语中说的指针通常指的是指针变量
//指针变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理）
//指针的大小在32位平台是4个字节，在64位平台是8个字节。
//int main()
//{
//	int a = 10;
//	int* p = &a; //这里我们对变量a，取出它的地址，可以使用&操作符。
//				//a变量占用4个字节的空间，这里是将a的4个字节的第一个字节的地址存放在p变量中，p就是一个指针变量。
//	printf("a在内存中的地址（指针）: %p\n", p);  // %p 是一个格式化输出控制符，用于输出指针变量的地址值。
//	
//	//指针的类型
//	char* pc = NULL;  // char* 类型的指针是为了存放 char 类型变量的地址。
//	int* pi = NULL;   // int* 类型的指针是为了存放 int 类型变量的地址
//	short* ps = NULL; // short* 类型的指针是为了存放 short 类型变量的地址。
//	long* pl = NULL;
//	float* pf = NULL;
//	double* pd = NULL;
//
//	return 0;
//}


//  指针+-整数
//int main()
//{
//	int n = 10;
//	char* pc = (char*)&n;
//	int* pi = &n;
//
//	printf("%p\n", &n);           //0000005DD2B9F804
//	printf("%p\n", pc);           //0000005DD2B9F804
//	printf("%p\n", pc + 1);       //0000005DD2B9F805
//	printf("%p\n", pi);           //0000005DD2B9F804
//	printf("%p\n", pi + 1);       //0000005DD2B9F808
//	printf("\n");
//	printf("int: %d\n", sizeof(int));	 // 4
//	printf("char: %d\n", sizeof(char));  // 1
//
//	// 指针的类型决定了指针向前或者向后走一步有多大（距离）
//
//	return 0;
//}


// 指针的解引用
//int main()
//{
//	int n = 0x11223344;
//	char* pc = (char*)&n;
//	int* pi = &n;
//	*pc = 0;   //重点在调试的过程中观察内存的变化。
//	*pi = 0;   //重点在调试的过程中观察内存的变化
//	//总结：
//	//指针的类型决定了，对指针解引用的时候有多大的权限（能操作几个字节）。
//	//比如： char* 的指针解引用就只能访问一个字节，而 int* 的指针的解引用就能访问四个字节。 |  ???没懂，调试没看到内存的变化!!
//
//	return 0;
//}


//野指针
//野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）
//int main()
//{
//	// 野指针成因:
//	//1.指针未初始化
//	//int* p;//局部变量指针未初始化，默认为随机值
//	//*p = 20;
//	//printf("指针未初始化: %p", p);  // 编译失败
//
//	//2.指针越界访问
//	//int arr[10] = { 0 };
//	//int* p = arr;   // 数组名是数组首元素的地址，所以取数组的地址不用 &arr
//	//int i = 0;
//	//for (i = 0; i <= 11; i++)
//	//{
//	//	//当指针指向的范围超出数组arr的范围时，p就是野指针
//	//	*(p++) = i;
//	//}
//
//	//3. 指针指向的空间释放
//
//	return 0;
//}

//如何规避野指针
//1. 指针初始化
//2. 小心指针越界
//3. 指针指向空间释放即使置NULL
//4. 避免返回局部变量的地址
//5. 指针使用之前检查有效性
//int main()
//{
//	int* p = NULL;
//	//....
//	int a = 10;
//	p = &a;
//	if (p != NULL)
//	{
//		printf("p: %p\n", p);  //0000002245D1F734
//		printf("a: %d\n", a);  //10
//		*p = 20;
//		printf("***** p: %p\n", p);  //0000002245D1F734
//		printf("重新赋值后 a: %d\n", a); //20
//	}
//
//	return 0;
//}
#include<windows.h>
#define N_VALUES 5
////指针运算
//int main()
//{
//	//  4.1指针 + -整数
//	//float values[N_VALUES];
//	//float* vp;
//
//	//int i = 0;
//	//for (i = 0; i < N_VALUES; i++)
//	//{
//	//	printf("values[i]: %f\n", values[i]);
//	//}
//
//	////指针+-整数；指针的关系运算
//	//for (vp = &values[0]; vp < &values[N_VALUES];)
//	//{
//	//	//赋值运算符 = 的优先级比后缀递增运算符 ++ 的优先级高，因此先执行赋值(=)操作，然后再执行递增(++)操作。
//	//	//首先，vp 指向的地址处存储的 float 值被设置为 0。
//	//	//然后，指针 vp 被递增，指向下一个 float 类型的地址。
//	//	*vp++ = 0;
//	//}
//
//	//int j = 0;
//	//for (j = 0; j < N_VALUES; j++)
//	//{
//	//	printf("values[i]---------: %f\n", values[j]);
//	//}
//	//printf("******************************************************\n");
//	//char s[20] = "*";
//	//printf("%s\n", s);
//
//	//char str[21];  // 定义一个长度为 21 的字符数组，用来存储字符串（包括结尾的 '\0'）
//
//	//for (int i = 0; i < 20; i++) {
//	//	str[i] = '*';  // 将每个字符设置为 '*'
//	//}
//
//	//str[20] = '\0';  // 在字符串的结尾添加一个 '\0'，表示字符串的结束
//
//	//printf("str: %s\n", str);  // 输出字符串
//	//printf("str : %d\n",strlen(str));   //20
//
//	////未初始化的数组的值是不确定的，因此 arr 数组中存储的数字是不确定的，可能是任意值。
//	//int arr[N_VALUES];
//	//int k = 0;
//	//for (k = 0; k < N_VALUES; k++)
//	//{
//	//	printf("int  arr[k]: %d\n", arr[k]);
//	//}
//
//	//	4.2指针 - 指针
//	//char str[5] = "abcde";
//	//char* p = str;   //字符串在 C 语言中是以字符数组的形式存储的，因此可以用字符指针指向字符串的首地址。
//	//char* s = str;
//	//printf("p: %p\n", p);
//	//printf("s: %p\n", s);
//	//while (*p != '\0')
//	//{
//	//	p++;   //str地址p递增，指向下一个地址，因为是char类型数据，所以地址每次增1个字节
//	//	printf("p---------: %p\n", p);
//	//	Sleep(1000);
//	//}	
//	//printf("p-s : %p\n", p - s);
//
//	//printf("int 占用 %d 字节\n", sizeof(int));  // 4
//
//	//int a = 10;
//	//int* pa = &a;
//	//printf("pa: %p\n", pa);
//	//while (1)
//	//{
//	//	pa++;  // pa指针变量指向int类型数据，地址每次递增4字节
//	//	printf("pa-----: %p\n", pa);
//	//	Sleep(1000);
//	//}
//
//	//	4.3指针的关系运算
//	//允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，
//	// 但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。
//
//	return 0;
//}

//5.指针与数组
//int main()
//{
//	// 数组名表示的是数组首元素的地址
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
//	printf("arr: %p\n", arr);  //000000C5AABFF858
//	printf("arr[0]: %p\n", arr[0]);  //0000000000000001    打印数组中首个元素
//	printf("&arr[0]: %p\n", &arr[0]); //000000C5AABFF858    数组首元素的地址
//	
//	int* p = arr;
//	printf("p: %p\n", p); //p存放的是数组首元素的地址
//
//	return 0;
//}

//int main()
//{
//	//int arr[] = { 1,2,3,4,5,6,7,8,9,0 };
//	//int* p = arr; //指针存放数组首元素的地址
//	//printf("p: %p\n", p);
//	//int sz = sizeof(arr) / sizeof(arr[0]);
//	//printf("sz: %d\n", sz);
//	//int i = 0;
//	//for (i = 0; i < sz; i++)
//	//{
//	//	printf("&arr[%d] = %p   <====> p+%d = %p\n", i, &arr[i], i, p + i);
//	//}
//
//	//p: 0000009AE00FF958
//	//sz : 10
//	//& arr[0] = 0000009AE00FF958   <=== = > p + 0 = 0000009AE00FF958
//	//& arr[1] = 0000009AE00FF95C   <=== = > p + 1 = 0000009AE00FF95C
//	//& arr[2] = 0000009AE00FF960   <=== = > p + 2 = 0000009AE00FF960
//	//& arr[3] = 0000009AE00FF964   <=== = > p + 3 = 0000009AE00FF964
//	//& arr[4] = 0000009AE00FF968   <=== = > p + 4 = 0000009AE00FF968
//	//& arr[5] = 0000009AE00FF96C   <=== = > p + 5 = 0000009AE00FF96C
//	//& arr[6] = 0000009AE00FF970   <=== = > p + 6 = 0000009AE00FF970
//	//& arr[7] = 0000009AE00FF974   <=== = > p + 7 = 0000009AE00FF974
//	//& arr[8] = 0000009AE00FF978   <=== = > p + 8 = 0000009AE00FF978
//	//& arr[9] = 0000009AE00FF97C   <=== = > p + 9 = 0000009AE00FF97C
//
//	//所以 p+i 其实计算的是数组 arr 下标为i的地址。
//	//那我们就可以直接通过指针来访问数组。
//	int arr[] = { 1,2,3,4,5,6,7,8,9,0 };
//	int* p = arr;  //指针存放数组首元素的地址
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int i = 0;
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d\n", *(p + i));
//	}
//	return 0;
//}


//6.二级指针
//指针变量也是变量，是变量就有地址，那指针变量的地址存放在哪里？这就是 二级指针 。
//指针变量存储的是某个内存地址的值，而二级指针是指向指针变量的指针。也就是说，二级指针存储的是某个指针变量的地址。
//定义一个二级指针的方法是在指针变量前面加上* ，如 int** p。这里的 p 是一个二级指针，它存储的是某个指针变量的地址。
//int main()
//{
//	int a = 10;
//	int* pa = &a;  //pa是一级指针
//	int** ppa = &pa; // ppa是二级指针
//	//pa 是一个指向 a 的指针变量，它存储了 a 的地址。
//	//通过* pa 可以访问 a 的值，这个操作叫做解引用（dereferencing），即获取指针所指向的内存地址上存储的值。
//	//因此，* pa 就代表了 a 的值。
//	printf("pa: %p\n", pa);
//	printf("ppa: %p\n", ppa);
//	printf("&a: %p\n", &a);
//
//	// 二级指针的运算
//	//*ppa 通过对ppa中的地址进行解引用，这样找到的是 pa ，* ppa 其实访问的就是 pa .
//	int b = 20;
//	//*ppa = &b;//等价于 pa = &b
//	//printf("*ppa: %d\n", *ppa);
//	//printf("ppa---: %p\n", ppa);
//
//	printf("******************************\n");
//	//**ppa 先通过 *ppa 找到 pa ,然后对 pa 进行解引用操作： *pa ，那找到的是 a
//	**ppa = 30;
//	//等价于*pa = 30;
//	//等价于a = 30
//	printf("**ppa------: %d\n", **ppa); // **ppa代表 a的值
//	printf("*ppa------: %d\n", *ppa); // *ppa代表 pa的值
//	printf("ppa------: %p\n", ppa);  // ppa代表pa的地址
//	printf("******************************\n");
//	printf("*pa--------: %d\n", *pa);
//	printf("pa---------: %p\n", pa);
//	printf("a: %d\n", a);
//
//	return 0;
//}


//7.指针数组
//int main()
//{
//	//指针数组是数组。是存放指针的数组
//	int* arr3[5];
//	int i = 0;
//	for (i = 0; i < 5; i++)
//	{
//		printf("arr3[i]: %p\n", arr3[i]);
//	}
//	return 0;
//}

