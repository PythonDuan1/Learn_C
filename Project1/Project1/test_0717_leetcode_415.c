#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>
#include <stdlib.h>
#include <math.h>


//415. 字符串相加
//给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。
//你不能使用任何冉ǖ挠糜诖理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。
//提示：
//1 <= num1.length, num2.length <= 104
//num1 和num2 都只包含数字 0 - 9
//num1 和num2 都不包含任何前导零
// 示例1：
	//输入：num1 = "11", num2 = "123"
	//输出："134"


//方法一：模拟
//思路与算法
//
//本题我们只需要对两个大整数模拟「竖式加法」的过程。竖式加法就是我们平常学习生活中常用的对两个整数相加的方法，
// 回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位相加，
// 如果当前位和超过 10，则向高位进一位？因此我们只要将这个过程用代码写出来即可。
//
//具体实现也不复杂，我们定义两个指针 i 和 j 分别指向 num1 和 num2 的末尾，即最低位，
//同时定义一个变量 add  维护当前是否有进位，然后从末尾到开头逐位相加即可。
//你可能会想两个数字位数不同怎么处理，这里我们统一在指针当前下标处于负数的时候返回 0，
//等价于对位数较短的数字进行了补零操作，这样就可以除去两个数字位数不同情况的处理，具体可以看下面的代码。


char* addStrings(char* num1, char* num2) {
    int i = strlen(num1) - 1, j = strlen(num2) - 1, add = 0;
    //fmax() 是一个库函数，用于返回两个浮点数中的最大值
    //malloc() 是一个库函数，用于动态分配内存空间，可以用于在运行时动态地分配一定大小的内存空间。
    //malloc() 函数需要传入一个整型参数，表示需要分配的内存空间的大小（单位为字节），函数返回一个指向分配的内存空间的指针。
    char* ans = (char*)malloc(sizeof(char) * (fmax(i, j) + 3));
    int len = 0;
    while (i >= 0 || j >= 0 || add != 0) {
        // num1[i] - '0' 表示将 num1 数组中的字符转换为整型数字，例如字符 '1' 转换为整型数字 1
        //将字符类型变量减去字符 '0' 的 ASCII 码值，可以得到对应的整型数字
        int x = i >= 0 ? num1[i] - '0' : 0;   
        int y = j >= 0 ? num2[j] - '0' : 0;
        int result = x + y + add;
        ans[len++] = '0' + result % 10; // '%'是取余。 这段代码是将result 的个位数字转换为字符
        add = result / 10;  // '/'是取整  / 运算符表示整数除法
        i--, j--;
    }
    // 计算完以后的答案需要翻转过来
    for (int i = 0; 2 * i < len; i++) {
        int t = ans[i];
        ans[i] = ans[len - i - 1], ans[len - i - 1] = t;
    }
    ans[len++] = 0;  //ans 字符数组的末尾添加了空字符 '\0'。 并将字符数组的长度加 1，以确保数组足够容纳空字符
    return ans;
}

//int main()
//{
//	char num1[] = "11";
//	char num2[] = "123";
//	char* res = addStrings(num1, num2); //返回字符指针
//    //printf("res 解引用: %d\n", *res);
//    printf("res : %s\n", res); //该字符数组的末尾添加了空字符 '\0'，因此 printf() 函数可以自动输出该字符数组中的内容，而不需要解引用操作
//
//    printf("字符转整型: %d\n", '1' - '0');
//    //typeof 运算符是 GCC 编译器的扩展功能，不是标准 C 语言的一部分。
//    //printf("'1' - '0' 结果的类型为 %d\n", typeof('1' - '0'));
//    printf("'12 % 10': %d\n", 12 % 10);
//    printf("12 / 10: %d\n", 12 / 10);
//    printf("9 % 10: %d\n", 9 % 10);
//    printf("9 / 10: %d\n", 9 / 10);
//
//	return 0;
//}